public class IndexableSkipList extends AbstractSkipList {
    final protected double probability;

    public IndexableSkipList(double probability) {
        super();
        this.probability = probability;
    }

    /**
     * @param val - the value of the key we're looking for.
     * @return the node of the key val, or the node previous to the supposed location of such a
     * node, if not in the data structure.
     * We're assuming INTEGER.MIN_VALUE < value < INTEGER.MAX_VALUE
     */
    @Override
    public Node find(int val) {
        Node p = head;
        for (int i = head.height(); i >= 0; i--) {
            while (p.getNext(i) != null && p.getNext(i).key() <= val)
                p = p.getNext(i);
        }
        return p;
    }

    /**
     * @return a height generated by the result of a geometric process (defined below) with
     * probability p in (0, 1), where p is a parameter of the data-structure.
     *
     * @random: The result of a Geometric Process with probability p
     * is the number of coin tosses until the first
     * success ("head") (including), with probability p for success.
     */
    @Override
    public int generateHeight() {
        int height = 0;
        while (Math.random() > probability) height++; //Tail
        return height;
    }
    // Returns the rank of the closest key
    public int rank(int val) {
        Node p = head;
        int rank = 0;
        for (int i = head.height(); i >= 0 && p.key() != val; i--) {
            while (p.getNext(i) != null && p.getNext(i).key() <= val) {
                rank += p.getSkip_size(i);
                p = p.getNext(i);
            }
        }
        return rank;
    }

    public int select(int index) {
        Node p = head;
        for (int i = head.height(); i >= 0 && index > 0; i--) {
            while (p.getNext(i) != null && p.getSkip_size(i) - index <= 0) {
                index -= p.getSkip_size(i);
                p = p.getNext(i);
            }
        }
        return p.key();
    }


    public static void main(String [] args){
        /*IndexableSkipList l1 = new IndexableSkipList(0.5);
        l1.insert(1);
        l1.insert(2);
        l1.insert(3);
        l1.delete(l1.head.getNext(0).getNext(0));
        System.out.println(l1);

        Node curr = l1.head;
        for(int i = 0; i<l1.size; i++){
            curr = curr.getNext(0);
            System.out.println(curr.key() + " rank is:" + l1.rank(curr.key()));
        }
        curr = l1.head;
        for(int i = 0; i<l1.size+1; i++){
            System.out.println(curr.key() + " skip-list is:" + curr.getSkip_size());
            curr = curr.getNext(0);
        }*/
        for(int j = 0; j < 10000; j++){
            IndexableSkipList l1 = new IndexableSkipList(0.5);
            l1.insert(2);
            l1.insert(1);
            l1.insert(4);
            l1.insert(5);
            l1.insert(3);
            l1.insert(6);
            if(l1.select(1) != 1 || l1.select(2) != 2 || l1.select(3) != 3 || l1.select(4) != 4 || l1.select(5) != 5 || l1.select(6) != 6){
                Node curr = l1.head;
                for(int i = 0; i<l1.size; i++){
                    curr = curr.getNext(0);
                    System.out.println(curr.key() + " rank is:" + l1.rank(curr.key()));
                }
                curr = l1.head;
                for(int i = 0; i<l1.size+1; i++){
                    System.out.println(curr.key() + " skip-list is:" + curr.getSkip_size());
                    curr = curr.getNext(0);
                }
            }
            l1.delete(l1.head.getNext(0)); // delete 1
            l1.delete(l1.head.getNext(0).getNext(0).getNext(0)); // delete 4
            l1.delete(l1.head.getNext(0).getNext(0).getNext(0).getNext(0)); // delete 6
            if(l1.rank(2) != 1 || l1.rank(3) != 2 || l1.rank(5) != 3){
                Node curr = l1.head;
                for(int i = 0; i<l1.size; i++){
                    curr = curr.getNext(0);
                    System.out.println(curr.key() + " rank is:" + l1.rank(curr.key()));
                }
                curr = l1.head;
                for(int i = 0; i<l1.size+1; i++){
                    System.out.println(curr.key() + " skip-list is:" + curr.getSkip_size());
                    curr = curr.getNext(0);
                }
            }

        }
    }
}